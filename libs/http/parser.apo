enum AuthKind {
    Bearer(String)
    Basic(String)
}

impl AuthKind {
    fn from_str(value: String) -> AuthKind {
        let whitespace : i8 = value.find(' ')
        let kind = value.range(0, whitespace)
        let auth_value = value.range(whitespace+1, value.len)
        if "Bearer" == kind.data {
            return AuthKind.Bearer(auth_value)
        }else{
            return AuthKind.Basic(auth_value)
        }
    }
}

enum HttpMethod {
    Get
    Post
    Delete
    Put
    Patch
    Head
    Options
}

impl HttpMethod {
    fn parse(data: String) -> HttpMethod {
        let new_line : i8 = data.find('\n')
        let method_str = data.range(0, new_line - 1)
        if "GET" == method_str.data {
            return HttpMethod.Get
        }else if "POST" == method_str.data {
            return HttpMethod.Post
        }else if "DELETE" == method_str.data {
            return HttpMethod.Delete
        }else if "PUT" == method_str.data {
            return HttpMethod.Put
        }else if "PATCH" == method_str.data {
            return HttpMethod.Patch
        }else if "HEAD" == method_str.data {
            return HttpMethod.Head
        }else{
            return HttpMethod.Options
        }
    }
}

enum Header {
    ContentType(String)
    Authentication(AuthKind)
    ContentLength(ui8)
}

impl Header {
    fn print(self: Header) {
        if self.ContentType(ct) {
            printf("Content-Type: %s\n", ct)
        }else if self.Authentication(auth) {
            printf("Auth\n")
        }else if self.ContentLength(len) {
            printf("Content-Length: %d\n", len)
        }
        return
    }

    fn from_string(kind: String, value: String) -> Header {
        if "Content-Type" == kind.data {
            return Header.ContentType(value)
        }else if "Content-Length" == kind.data {
            let conv = value.to_int() as ui8
            return Header.ContentLength(conv)
        }else if "Authentication" == kind.data {
            return Header.Authentication(AuthKind.from_str(value))
        }
        return Header.ContentLength(0 as ui8)
    }
}

enum Option {
	Some(Header)
	None
}

struct HeaderLL {
	header: Header
	next: Option
}

struct Headers {
    headers: Option
    size: i4
}

impl Headers {
    fn build(data: String, out: &ui8) -> Headers {
        let result = data.split('\n')
		let head = Option.None
        let next = &head
        let count = 0
        let flag = false
        for i in (0..result.count) {
            let line = result.slice[i]
            flag = line.is_empty()
            if !flag {
                count += 1
            }
        }
        for i in (0..count) {
            let line = result.slice[i]
            let line_end : i8 = data.find('\n')
            let kind_end : i8 = data.find(':')
            let kind = data.range(0, kind_end)
            let value = data.range(kind_end+1, line_end)
            let header = Header.from_string(kind, value)
			let deref = ^next
			if deref.None {
			}
			if deref.Some(header) {
			}
        }
        return new Headers { headers: head size: count }
    }

    fn print(self: &Headers) {
        for i in (0..self.size) {
            let header = self.headers[i]
            header.print()
        }
        return
    }
}

struct Request {
    method: HttpMethod
    path: String
    headers: &Headers
    payload: &ui1
}

impl Request {
    fn parse(data: String) -> Request {
        let new_line = data.find('\n')
        let method = HttpMethod.parse(data)
        let path_start : i8 = data.find(' ')
        let sub = data.range(path_start , new_line)
        let path_end = sub.find(' ')
        let path = data.range(path_start, path_end)
        printf("Path is %s with len %d\n", path.fmt(), path.len)
        let headers_str = data.range(new_line + 1, data.len - new_line - 1)
        let out : ui8 = 0
        let headers : &Headers = Headers.build(headers_str, &out)
        let payload = headers_str.range(out, headers_str.len)
        return new Request { method: method path: path headers: headers payload: payload.data }
    }
}
