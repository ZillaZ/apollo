enum AuthKind {
    Bearer(String)
    Basic(String)
}

impl AuthKind {
    fn from_str(value: String) -> AuthKind {
        let whitespace : i8 = value.find(' ')
        let kind = value.range(0, whitespace)
        let auth_value = value.range(whitespace+1, value.len)
        if "Bearer" == kind.data {
            return AuthKind.Bearer(auth_value)
        }else{
            return AuthKind.Basic(auth_value)
        }
    }
}

enum HttpMethod {
    Get
    Post
    Delete
    Put
    Patch
    Head
    Options
}

impl HttpMethod {
    fn parse(data: String) -> HttpMethod {
        let space : i8 = data.find(' ')
        if space < 0 { exit(1) }
        let method_str = data.range(0, space)
        method_str.trim()
        if method_str.eq_str("GET") {
            return HttpMethod.Get
        }else if method_str.eq_str("POST") {
            return HttpMethod.Post
        }else if method_str.eq_str("DELETE") {
            return HttpMethod.Delete
        }else if method_str.eq_str("PUT") {
            return HttpMethod.Put
        }else if method_str.eq_str("PATCH") {
            return HttpMethod.Patch
        }else if method_str.eq_str("HEAD") {
            return HttpMethod.Head
        }else{
            return HttpMethod.Options
        }
    }

    fn print(self: HttpMethod) {
        if self.Get {
            printf("GET\n")
        }else if self.Post {
            printf("POST\n")
        }else{
            printf("Not implemented yet\n")
        }
        return
    }

    fn fmt(self: HttpMethod) -> string {
        if self.Get {
            return "GET"
        }else if self.Post {
            return "POST"
        }
        return "Not implemented yet"
    }
}

struct Header {
key: String
value: String
}

impl Header {
    fn print(self: &Header) {
        printf("%s: %s\n", self.key.fmt(), self.value.fmt())
        return
    }

    fn from_string(key: String, value: String) -> Header {
        return new Header { key: key value: value }
    }

    fn to_string(self: &Header) -> String {
        let rtn = String.new()
        rtn.push(self.key)
        rtn.push_str(": ", 2)
        rtn.push(self.value)
        return rtn
    }

    fn free(self: &Header) {
        self.key.free()
        self.value.free()
        return
    }
}

struct Headers {
    headers: &Header
    size: ui8
    capacity: ui8
}

impl Headers {
    fn new() -> Headers {
        let capacity = 8
        let aux : Header
        return new Headers { headers: malloc(size_of(aux) * capacity) size: 0 capacity: capacity}
    }

    fn to_string(self: &Headers) -> String {
        let rtn = String.new()
        for i in (0..self.size) {
            let header_str = self.headers[i].to_string()
            rtn.push(header_str)
            rtn.push_char('\n')
            header_str.free()
        }
        return rtn
    }

    fn free(self: &Headers) {
        for i in (0..self.size) {
            self.headers[i].free()
        }
        return
    }

    fn push(self: &Headers, header: Header) {
        if self.size == (self.capacity - 1) {
            self.capacity *= 2
            self.headers = realloc(self.headers, size_of(header) * self.capacity)
        }
        self.headers[self.size] = header
        self.size += 1
        return
    }

    fn build(data: String) -> Headers {
        let offset = 0
        let flag = false
        let headers = Headers.new()
        while !flag {
            let copy = data.range(offset, data.len)
            let line_end = copy.find('\n')
            if line_end == (-1) {
                line_end = data.len
                flag = true
            }else{
                offset += line_end + 1
            }
            let line = copy.range(0, line_end)
            if (!flag) && line.is_empty() {
                flag = true
            }else{
                let kind_end : i8 = line.find(':')
                if kind_end < 0 { exit(2) }
                let kind = line.range(0, kind_end)
                let value = line.range(kind_end+1, line.len)
                let a = malloc(10)
                let header = Header.from_string(kind, value)
                headers.push(header)
            }
        }
        return headers
    }

    fn print(self: &Headers) {
        for i in (0..self.size) {
            self.headers[i].print()
        }
        return
    }

    fn get(self: &Headers, target: string) -> HeaderOption {
        for i in (0..self.size){
            if target == self.headers[i].key.data {
                return HeaderOption.Some(self.headers[i].value)
            }
        }
        return HeaderOption.None
    }
}

enum HeaderOption {
    Some(String)
    None
}

struct Request {
    method: HttpMethod
    path: String
    headers: Headers
    payload: String
}

impl Request {
    fn parse(data: String) -> Request {
        let new_line = data.find('\n')
        if new_line < 0 { exit(90) }
        let method = HttpMethod.parse(data)
        let path_start : i8 = data.find(' ') + 1
        if path_start < 0 { exit(100) }
        let sub = data.range(path_start, new_line)
        let path_end = sub.find(' ') + path_start
        if path_end < 0 { exit(99) }
        let path = data.range(path_start, path_end)
        path.trim()
        let first_line = data.range(0, new_line)
        let headers_str = data.range(new_line + 1, data.len)
        let headers : Headers = Headers.build(headers_str)
        let flag = false
        let offset = 0
        while !flag {
            let copy = headers_str.range(offset, headers_str.len)
            let line_end = copy.find('\n')
            if line_end == (-1) {
                flag = true
            }else{
                let line = copy.range(0, line_end)
                offset += line_end + 1
                flag = line.is_empty()
            }
        }
        let payload = headers_str.range(offset, headers_str.len)
        return new Request { method: method path: path headers: headers payload: payload }
    }

    fn free(self: &Request) {
        self.path.free()
        self.headers.free()
        self.payload.free()
        return
    }
}

struct Response {
    code: i4
    message: String
    headers: Headers
    payload: String
}

impl Response {
    fn ok() -> Response {
        return new Response { code: 200 message: String.from_str("OK") headers: Headers.new() payload: String.new() }
    }

    fn not_found() -> Response {
        return new Response { code: 404 message: String.from_str("Not Found") headers: Headers.new() payload: String.new() }
    }

    fn as_string(self: &Response) -> String {
        let response = String.from_str("HTTP/1.1")
        response.push_char(' ')
        let code = self.code.to_string()
        response.push(code)
        code.free()
        response.push_char(' ')
        response.push(self.message)
        response.push_char('\n')
        let headers_str = self.headers.to_string()
        response.push(headers_str)
        headers_str.free()
        response.push_char('\n')
        response.push(self.payload)
        return response
    }

    fn free(self: &Response) {
        self.message.free()
        self.headers.free()
        self.payload.free()
        return
    }
}
