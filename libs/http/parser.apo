enum AuthKind {
    Bearer(String)
    Basic(String)
}

impl AuthKind {
    fn from_str(value: String) -> AuthKind {
        let whitespace : i8 = value.find(' ')
        let kind = value.range(0, whitespace)
        let auth_value = value.range(whitespace+1, value.len)
        if "Bearer" == kind.data {
            return AuthKind.Bearer(auth_value)
        }else{
            return AuthKind.Basic(auth_value)
        }
    }
}

enum HttpMethod {
    Get
    Post
    Delete
    Put
    Patch
    Head
    Options
}

impl HttpMethod {
    fn parse(data: String) -> HttpMethod {
        let space : i8 = data.find(' ')
        let method_str = data.range(0, space)
        if "GET" == method_str.data {
            return HttpMethod.Get
        }else if "POST" == method_str.data {
            return HttpMethod.Post
        }else if "DELETE" == method_str.data {
            return HttpMethod.Delete
        }else if "PUT" == method_str.data {
            return HttpMethod.Put
        }else if "PATCH" == method_str.data {
            return HttpMethod.Patch
        }else if "HEAD" == method_str.data {
            return HttpMethod.Head
        }else{
            return HttpMethod.Options
        }
    }
    fn print(self: HttpMethod) {
        if self.Get {
            printf("GET\n")
        }else if self.Post {
            printf("POST\n")
        }else{
            printf("Not implemented yet\n")
        }
        return
    }
}

struct Header {
key: String
value: String
}

impl Header {
    fn print(self: &Header) {
        printf("%s: %s\n", self.key.fmt(), self.value.fmt())
        return
    }

    fn from_string(key: String, value: String) -> Header {
        return new Header { key: key value: value }
    }
}

struct Headers {
    headers: &Header
    size: ui8
    capacity: ui8
}

impl Headers {
    fn new() -> Headers {
        let capacity = 8
        return new Headers { headers: malloc(size_of(Header) * capacity) size: 0 capacity: capacity}
    }

    fn push(self: &Headers, header: Header) {
        if self.size == (self.capacity - 1) {
            self.capacity *= 2
            self.headers = realloc(self.headers, size_of(Header) * self.capacity)
        }
        self.headers[self.size] = header
        self.size += 1
        return
    }

    fn build(data: String) -> Headers {
        let offset = 0
        let flag = false
        let headers = Headers.new()
        while !flag {
            let copy = data.range(offset, data.len)
            let line_end = copy.find('\n')
            if line_end == (-1) {
                line_end = data.len
                flag = true
            }else{
                offset += line_end + 1
            }
            let line = copy.range(0, line_end)
            if (!flag) && line.is_empty() {
                flag = true
            }else{
                let kind_end : i8 = line.find(':')
                let kind = line.range(0, kind_end)
                let value = line.range(kind_end+1, line.len)
                let header = Header.from_string(kind, value)
                headers.push(header)
            }
        }
        return headers
    }

    fn print(self: &Headers) {
        for i in (0..self.size) {
            self.headers[i].print()
        }
        return
    }

    fn get(self: &Headers, target: string) -> HeaderOption {
        for i in (0..self.size){
            if target == self.headers[i].key.data {
                return HeaderOption.Some(self.headers[i].value)
            }
        }
        return HeaderOption.None
    }
}

enum HeaderOption {
    Some(String)
    None
}

struct Request {
    method: HttpMethod
    path: String
    headers: Headers
    payload: &ui1
}

impl Request {
    fn parse(data: String) -> Request {
        let new_line = data.find('\n')
        let method = HttpMethod.parse(data)
        let path_start : i8 = data.find(' ')
        let sub = data.range(path_start, new_line)
        let path_end = sub.find(' ') + path_start
        let path = data.range(path_start, path_end)
        let first_line = data.range(0, new_line)
        let headers_str = data.range(new_line + 1, data.len)
        let headers : Headers = Headers.build(headers_str)
        let flag = false
        let offset = 0
        while !flag {
            let copy = headers_str.range(offset, headers_str.len)
            let line_end = copy.find('\n')
            if line_end == (-1) {
                flag = true
            }else{
                let line = copy.range(0, line_end)
                offset += line_end + 1
                flag = line.is_empty()
            }
        }
        let payload = headers_str.range(offset, headers_str.len)
        return new Request { method: method path: path headers: headers payload: payload.data }
    }
}
