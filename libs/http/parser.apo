enum AuthKind {
    Bearer(String)
    Basic(String)
}

impl AuthKind {
    fn from_str(value: String) -> AuthKind {
        let whitespace : i8 = value.find(' ')
        let kind = value.range(0, whitespace)
        let auth_value = value.range(whitespace+1, value.len)
        if "Bearer" == kind.data {
            return AuthKind.Bearer(auth_value)
        }else{
            return AuthKind.Basic(auth_value)
        }
    }
}

enum HttpMethod {
    Get
    Post
    Delete
    Put
    Patch
    Head
    Options
}

impl HttpMethod {
    fn parse(data: String) -> HttpMethod {
        let space : i8 = data.find(' ')
        let method_str = data.range(0, space)
        if "GET" == method_str.data {
            return HttpMethod.Get
        }else if "POST" == method_str.data {
            return HttpMethod.Post
        }else if "DELETE" == method_str.data {
            return HttpMethod.Delete
        }else if "PUT" == method_str.data {
            return HttpMethod.Put
        }else if "PATCH" == method_str.data {
            return HttpMethod.Patch
        }else if "HEAD" == method_str.data {
            return HttpMethod.Head
        }else{
            return HttpMethod.Options
        }
    }
    fn print(self: HttpMethod) {
        if self.Get {
            printf("GET\n")
        }else if self.Post {
            printf("POST\n")
        }else{
            printf("Not implemented yet\n")
        }
        return
    }
}

struct Header {
key: String
value: String
}

impl Header {
    fn print(self: &Header) {
        printf("%s: %s\n", self.key.fmt(), self.value.fmt())
        return
    }

    fn from_string(key: String, value: String) -> Header {
        return new Header { key: key value: value }
    }
}

struct Headers {
    headers: &Header
    size: i4
}

impl Headers {
    fn build(data: String, out: &ui8) -> Headers {
        let result = data.split('\n')
        let count = 0
        let flag = false
        for i in (0..result.count) {
            let line = result.slice[i]
            if !flag {
                flag = line.is_empty()
                printf("Line %s | Is empty: %d\n", flag)
            }
            if !flag {
                count += 1
            }
        }
        let headers: &Header = malloc(count * size_of(Header))
        for i in (0..count) {
            let line = result.slice[i]
            let kind_end : i8 = line.find(':')
            let kind = line.range(0, kind_end)
            let value = line.range(kind_end+1, line.len)
            let header = Header.from_string(kind, value)
            headers[i] = header
        }
        return new Headers { headers: headers size: count }
    }

    fn print(self: &Headers) {
        for i in (0..self.size) {
            self.headers[i].print()
        }
        return
    }
}

struct Request {
    method: HttpMethod
    path: String
    headers: Headers
    payload: &ui1
}

impl Request {
    fn parse(data: String) -> Request {
        let new_line = data.find('\n')
        let method = HttpMethod.parse(data)
        let path_start : i8 = data.find(' ')
        let sub = data.range(path_start, new_line)
        let path_end = sub.find(' ') + path_start
        let path = data.range(path_start, path_end)
        let first_line = data.range(0, new_line)
        let headers_str = data.range(new_line + 1, data.len - new_line - 1)
        let out : ui8 = 0
        let headers : Headers = Headers.build(headers_str, &out)
        let payload = headers_str.range(out, headers_str.len)
        return new Request { method: method path: path headers: headers payload: payload.data }
    }
}
