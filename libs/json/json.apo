enum JsonParserResult {
	Err(String)
	PartialOk
	Value(JsonValue)
	Field(&JsonField)
}

impl JsonParserResult {
	fn is_err(self: &JsonParserResult) -> bool {
		let aux = ^self
		if aux.Err(reason) {
			return true
		}
		return false
	}
}

enum JsonValue {
	Integer(i8)
	Float(f4)
	String(String)
	Object(&JsonObject)
	List(&JsonList)
	Boolean(bool)
	Nil
}

impl JsonValue {
	fn new() -> JsonValue {
		return JsonValue.Integer(0 as i8)
	}

	fn as_object(self: JsonValue) -> JsonObject {
		if self.Object(object) {
			return ^object
		}else{
			printf("Tried to get json value as object, but it wasn't one\n")
			exit(0)
			return JsonObject.new()
		}
	}

	fn fmt(self: JsonValue) -> string {
		if self.Integer(val) {
			return val.fmt()
		}else if self.Object(obj) {
			return obj.fmt()
		}else if self.String(text) {
			return text.fmt()
		}else if self.List(list) {
			return list.fmt()
		}else if self.Nil {
			return "(null)"
		}else{
			return "not implemented yet"
		}
	}
}

struct JsonField {
	name: String
	value: JsonValue
}

impl JsonField {
	fn new() -> JsonField {
		return new JsonField { name: String.from_str("") value: JsonValue.new() }
	}
}

struct JsonObject {
	fields: &JsonField
	field_count: ui8
	capacity: ui8
}

impl JsonObject {
	fn new() -> JsonObject {
		let capacity = 128
		let aux : JsonField
		let fields : &JsonField = malloc(size_of(aux) * capacity)
		return new JsonObject { fields: fields field_count: 0 capacity: capacity }
	}

	fn fmt(self: &JsonObject) -> string {
		return "not implemented yet (object)"
	}

	fn push_field(self: &JsonObject, field: &JsonField) {
		if self.field_count >= (self.capacity - 1) {
			self.capacity *= 2
			self.fields = realloc(self.fields, self.capacity)
		}
		self.fields[self.field_count] = ^field
		self.field_count += 1
		return
	}

	fn get(self: &JsonObject, name: string) -> JsonValue {
		for i in (0..self.field_count) {
			let field = self.fields[i]
			if field.name.eq_str(name) {
				return field.value
			}
		}
		return JsonValue.Nil
	}

	fn free(self: &JsonObject) {
		self.field_count = 0
		self.capacity = 0
		return
	}
}

struct JsonList {
	elements: &JsonValue
	len: ui8
	capacity: ui8
}

impl JsonList {
	fn new() -> JsonList {
		let capacity = 128
		let aux: JsonValue
		return new JsonList { elements: malloc(size_of(aux) * capacity) len: 0 capacity: capacity }
	}

	fn push(self: &JsonList, elements: JsonValue) {
		if self.len >= (self.capacity - 1) {
			self.capacity *= 2
			self.elements = realloc(self.elements, self.capacity)
		}
		self.elements[self.len] = elements
		self.len += 1
		return
	}

	fn fmt(self: &JsonList) -> string {
		let buffer = String.from_str("[")
		for i in (0..(self.len-1)) {
			let element = self.elements[i]
			let fmt = element.fmt()
			buffer.push_str(fmt, 999999)
			free(fmt)
			buffer.push_char(',')
		}
		if self.len > 0 {
			let fmt = self.elements[self.len-1].fmt()
			buffer.push_str(fmt, 999999)
			free(fmt)
		}
		buffer.push_char(']')
		return buffer.data
	}

	fn free(self: &JsonList) {
		free(self.elements)
		self.len = 0
		self.capacity = 0
		return
	}
}

enum ValueKind {
	String
	Integer
	Float
	Object
	List
	Err(char)
}

struct JsonParser {
	buffer: String
	offset: ui8
	document: JsonValue
}

impl JsonParser {
	fn new(buffer: String) -> JsonParser {
		buffer.trim()
		let document = JsonValue.new()
		let rtn = new JsonParser { buffer: buffer offset: 0 document: document }
		return rtn
	}

	fn parse(self: &JsonParser) -> JsonParserResult {
		let result = self.build_value()
		if result.Err(err) {
			printf("Error while trying to build json: %s\n", err.data)
			exit(3)
		}
		return result
	}

	fn build_boolean(self: &JsonParser) -> JsonParserResult {
		let slice = self.buffer.slice(self.offset, self.buffer.len)
		let next = self.next_char()
		let offset = slice.find(next)
		self.offset += offset
		slice = self.buffer.slice(self.offset, self.buffer.len)
		let first = slice.first_match(",}]", 3)
		let number = self.capture_until(first.c)
		self.offset += first.index
		if number.eq_str("true") {
			return JsonParserResult.Value(JsonValue.Boolean(true))
		}else if number.eq_str("false") {
			return JsonParserResult.Value(JsonValue.Boolean(false))
		}else{
			return JsonParserResult.Err(String.from_str("Not a boolean"))
		}
	}

	fn build_integer(self: &JsonParser) -> JsonParserResult {
		let slice = self.buffer.slice(self.offset, self.buffer.len)
		let next = self.next_char()
		let offset = slice.find(next)
		self.offset += offset
		slice = self.buffer.slice(self.offset, self.buffer.len)
		let first = slice.first_match(",}]", 3)
		let number = self.capture_until(first.c)
		let number = number.clone()
		number.trim()
		self.offset += first.index
		let number = number.to_int()
		return JsonParserResult.Value(JsonValue.Integer(number as i8))
	}

	fn build_float(self: &JsonParser) -> JsonParserResult {
		return JsonParserResult.Err(String.from_str("Not implemented yet"))
	}

	fn build_object(self: &JsonParser) -> JsonParserResult {
		let object = JsonObject.new()
		let rtn = JsonParserResult.PartialOk
		let flag = true
		while flag {
			let result = self.build_field()
			if result.Err(err) {
				rtn = result
				flag = false
			}else if result.Field(field) {
				object.push_field(field)
				let slice = self.buffer.slice(self.offset, self.buffer.len)
				let first_match = slice.first_exclusive_match("},", 2)
				if (first_match.index < 0) {
					rtn =  JsonParserResult.Err(String.from_str("MUITO SEXO"))
					flag = false
				}else if first_match.c == '}' {
					rtn = JsonParserResult.Value(JsonValue.Object(&object))
					flag = false
				}else if first_match.c == ',' {
					self.offset += first_match.index + 1
				}
			}else{
				rtn = JsonParserResult.Err(String.from_str("Unexpected result coming from build field (at build object)"))
				flag = false
			}
		}
		return rtn
	}

	fn build_list(self: &JsonParser) -> JsonParserResult {
		let aux : JsonList
		let list : &JsonList = malloc(size_of(aux))
		^list = JsonList.new()
		let next = self.next_char()
		if next != '[' {
			exit(2)
		}
		let slice = self.buffer.slice(self.offset, self.buffer.len)
		let offset = slice.find(next)
		self.offset += offset + 1
		let result = self.build_value()
		if result.Err(err) {
			return result
		}else if result.Value(value) {
			list.push(value)
		}
		slice = self.buffer.slice(self.offset, self.buffer.len)
		let first_match = slice.first_exclusive_match("],", 2)
		if (first_match.index < 0) {
			return JsonParserResult.Err(String.from_str("XERECA"))
		}
		if first_match.c == ']' {
			return JsonParserResult.Value(JsonValue.List(list))
		}
		while (first_match.index >= 0) and (first_match.c == ',') {
			self.offset += first_match.index + 1
			let result = self.build_value()
			if result.Err(err) {
				return result
			}else if result.Value(value) {
				list.push(value)
			}
			slice = self.buffer.slice(self.offset, self.buffer.len)
			first_match = slice.first_exclusive_match("],", 2)
		}
		if (first_match.index < 0) {
			return JsonParserResult.Err(String.from_str("XERECA"))
		}
		self.offset += first_match.index + 1
		return JsonParserResult.Value(JsonValue.List(list))
	}

	fn build_value(self: &JsonParser) -> JsonParserResult {
		let slice = self.buffer.slice(self.offset, self.buffer.len)
		let first_match = slice.first_exclusive_match("'\"{[", 4)
		if (first_match.index < 0) {
			let next = self.next_char()
			if next.is_whitespace() {
				return JsonParserResult.Err(String.from_str("potz next tem porra nenhumakkkk"))
			}
			let offset = slice.find(next)
			self.offset += offset
			slice = self.buffer.slice(self.offset, self.buffer.len)
			let first = slice.first_match(",}]", 3)
			if (first.index < 0) {
				exit(9)
			}
			let number = self.capture_until(first.c)
			self.offset -= offset
			let is_float = false
			if number.is_numerical(&is_float) {
				if !is_float {
					return self.build_integer()
				}
				return self.build_float()
			}
			return self.build_boolean()
		}
		let c = first_match.c
		if (c == '\'') or (c == '\"') {
			return self.build_string()
		}else if c == '{' {
			return self.build_object()
		}else if c == '[' {
			return self.build_list()
		}else{
			return JsonParserResult.Err(String.from_str("olha la meu nobregakkkkk"))
		}
	}

	fn next_char(self: &JsonParser) -> char {
		for i in (self.offset..self.buffer.len) {
			let c = self.buffer.data[i]
			if !c.is_whitespace() {
				return c
			}
		}
		return '\0'
	}

	fn capture_until(self: &JsonParser, target: char) -> String {
		for i in (self.offset..self.buffer.len) {
			let c = self.buffer.data[i]
			if target == c {
				return self.buffer.slice(self.offset, i)
			}
		}
		return self.buffer.slice(0, 0)
	}

	fn build_string(self: &JsonParser) -> JsonParserResult {
		let slice = self.buffer.slice(self.offset, self.buffer.len)
		let first_match = slice.first_match("'\"", 2)
		if (first_match.index < 0) {
			return JsonParserResult.Err(String.from_str("Couldn' find start string token ('\'' or '\"' were expected)"))
		}
		self.offset += first_match.index + 1
		slice = self.buffer.slice(self.offset, self.buffer.len)
		let end = slice.find_enclosing(first_match.c)
		if (end == (-1)) {
			return JsonParserResult.Err(String.from_str("Couldn' find end of string token ('\'' or '\"' were expected)"))
		}
		self.offset += end + 1
		let value = slice.slice(0, end)
		return JsonParserResult.Value(JsonValue.String(value.clone()))
	}

	fn build_field(self: &JsonParser) -> JsonParserResult {
		let field_name = self.build_string()
		let aux : JsonField
		let field : &JsonField = malloc(size_of(aux))
		^field = JsonField.new()
		if field_name.Err(err) {
			printf("Error while parsing field name: %s\n", err.data)
			exit(1)
		}else if field_name.Value(val) {
			if val.String(field_name) {
				field.name = field_name
				let slice = self.buffer.slice(self.offset, self.buffer.len)
				let dd = slice.find(':')
				if (dd < 0) {
					let error_msg = String.from_str("Failed to retrieve double dot after parsing field name \"")
					error_msg.push(field_name)
					error_msg.push_char('\"')
					return JsonParserResult.Err(error_msg)
				}
				self.offset += dd + 1
				let result = self.build_value()
				if result.Value(val) {
					field.value = val
					return JsonParserResult.Field(field)
				}else if result.Err(err) {
					printf("Error while trying to build field '%s' value: %s\n", field_name.data, err.data)
					exit(2)
				}
			}
		}
		return JsonParserResult.PartialOk
	}
}
