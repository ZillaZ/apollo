struct FirstMatch {
	c: char
	index: i8
}

struct SplitResult {
slice: &String
count: ui8
}

struct String {
data: &char
len: ui8
capacity: ui8
}

impl String {
	fn new() -> String {
		let capacity : ui8 = 128
		return new String { data: malloc(capacity) len: 0 capacity: capacity }
	}

	fn from_str(value: string) -> String {
		let len = strlen(value, 999999)
		if len == (-1) {
			exit(99)
		}
		let data : &char = malloc(len)
		memcpy(data, value, len)
		return new String { data: data len: len capacity: len }
	}

	fn range(self: &String, start: ui8, end: ui8) -> String {
		let rtn : &char = malloc(1 + end - start)
		let offset : &char = self.data[start]
		memcpy(rtn, offset, end - start)
		rtn[end - start] = '\0'
		return new String { data: rtn len: end - start capacity: end - start }
	}

	fn count(self: &String, target: char) -> ui8 {
		let count : ui8 = 0
		for i in (0..self.len) {
			if self.data[i] == target {
				count += 1
			}
		}
		return count
	}

	fn find(self: &String, target: char) -> i8 {
		for i in (0..self.len) {
			if self.data[i] == target {
				return i
			}
		}
		return -1
	}

	fn split(self: &String, target: char) -> SplitResult {
		let count : ui8 = self.count(target) + 1
		let rtn : &String = malloc(size_of(^self) * count)
		let offset : ui8 = 0
		for i in (0..count) {
			let aux = self.range(offset, self.len)
			let end = aux.find(target)
			if end == (-1) {
				end = aux.len
			}
			rtn[i] = aux.range(0, end)
			offset += end + 1
		}
		return new SplitResult { slice: rtn count: count }
	}

	fn is_empty(self: &String) -> bool {
		for i in (0..self.len) {
			if !self.data[i].is_whitespace() {
				return false
			}
		}
		return true
	}

	fn clone(self: &String) -> String {
		let alloc: &char = malloc(self.len)
		memcpy(alloc, self.data, self.len)
		return new String { data: alloc len: self.len capacity: self.capacity }
	}

	fn trim(self: &String) {
		let flag = false
		let l = 0
		while (l < self.len) and (!flag) {
			if self.data[l].is_whitespace() { l += 1 } else { flag = true }
		}
		let r = self.len
		while (r > l) and (!flag) {
			if self.data[r].is_whitespace() { r -= 1 } else { flag = true }
		}
		let alloc: &char = malloc(r - l + 1)
		let aux : &char = self.data[l]
		memcpy(alloc, aux, r - l)
		self.data = realloc(self.data, r - l + 1)
		memcpy(self.data, alloc, r - l)
		self.data[r - l] = '\0'
		self.len = r - l
		self.capacity = self.len
		return
	}

	fn to_int(self: String) -> i8 {
		let result : i8 = 0
		for i in (0..self.len) {
			result = result * 10 + (self.data[i] - 48)
		}
		return result
	}

	fn free(self: &String) {
		if self.len > 0 {
			free(self.data)
		}
		return
	}

	fn fmt(self: &String) -> string {
		return self.data
	}

	fn equals(self: &String, other: &String) -> bool {
		if self.len != other.len { return false }
		for i in (0..self.len) {
			if self.data[i] != other.data[i] {
				return false
			}
		}
		return true
	}

	fn eq_str(self: &String, other: string) -> bool {
		let len = strlen(other, self.len)
		if (len == (-1) or self.len != len) { return false }
		for i in (0..self.len) {
			if self.data[i] != other[i] { return false }
		}
		return true
	}

	fn push_char(self: &String, append: char) {
		self.check_bounds(1)
		self.data[self.len] = append
		self.len += 1
		return
	}

	fn push_str(self: &String, append: string, max: i8) {
		let len = strlen(append, max)
		self.check_bounds(len)
		let ptr : &char = self.data[self.len]
		memcpy(ptr, append, len)
		self.len += len
		return
	}

	fn push(self: &String, append: String) {
		self.check_bounds(append.len)
		let ptr : &char = self.data[self.len]
		memcpy(ptr, append.data, append.len)
		self.len += append.len
		return
	}

	fn check_bounds(self: &String, extra_size: i8) {
		if (self.len + extra_size) >= (self.capacity - 1) {
			self.capacity = self.len + extra_size
			self.data = realloc(self.data, self.capacity)
		}
		return
	}

	fn slice(self: &String, start: ui8, end: ui8) -> String {
		if (end < start) or (start > self.len) or (end > self.len) {
			exit(7)
		}
		let data : &char = self.data[start]
		let len = end - start
		let capacity = end - start
		return new String { data: data len: len capacity: capacity }
	}

	fn find_enclosing(self: &String, target: char) -> i8 {
		let escaped = false
		for i in (0..self.len) {
			let c = self.data[i]
			if escaped {
				escaped = false
			}else if (c == '\\') {
                escaped = true
            }else if (target == c) {
				return i
			}
		}
		return -1
	}

	fn first_match(self: &String, targets: &char, len: ui8) -> FirstMatch {
		for i in (0..self.len) {
			let out = self.data[i]
			for j in (0..len) {
				let in = targets[j]
				if in == out {
					return new FirstMatch { c: in index: i }
				}
			}
		}
		return new FirstMatch { c: ' ' index: (-1) }
	}

	fn first_exclusive_match(self: &String, targets: &char, len: ui8) -> FirstMatch {
		for i in (0..self.len) {
			let out = self.data[i]
			for j in (0..len) {
				let in = targets[j]
				if in == out {
					return new FirstMatch { c: in index: i }
				}
			}
			if !out.is_whitespace() {
				return new FirstMatch { c: ' ' index: (-1) }
			}
		}
		return new FirstMatch { c: ' ' index: (-1) }
	}


	fn is_numerical(self: &String, is_float: &bool) -> bool {
		for i in (0..self.len) {
			let c = self.data[i]
			if ^is_float and c == '.' {
				return false
			}else if c == '.' {
				^is_float = true
			}else if c.is_whitespace() or (c < 48) or (c > 58) {
				return false
			}
		}
		return true
	}
}

fn strlen(other: string, max: i8) -> i8 {
	for i in (0..max) {
		if other[i] == '\0' { return i }
	}
	return -1
}
