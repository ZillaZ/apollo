struct SplitResult {
slice: &String
count: ui8
}

struct String {
data: &char
len: ui8
capacity: ui8
}

impl String {
	fn new() -> String {
		let capacity : ui8 = 128
		return new String { data: malloc(capacity) len: 0 capacity: capacity }
	}

	fn from_str(value: string) -> String {
		let i = 0
		while value[i] != '\0' {
			i += 1
		}
		return new String { data: value len: i capacity: i }
	}

	fn range(self: &String, start: ui8, end: ui8) -> String {
		let rtn : &char = malloc(1 + end - start)
		let offset : &char = self.data[start]
		memcpy(rtn, offset, end - start)
		rtn[end] = '\0'
		return new String { data: rtn len: end - start capacity: end - start }
	}

	fn count(self: &String, target: char) -> ui8 {
		let count : ui8 = 0
		for i in (0..self.len) {
			if self.data[i] == target {
				count += 1
			}
		}
		return count
	}

	fn find(self: &String, target: char) -> i8 {
		for i in (0..self.len) {
			if self.data[i] == target {
				return i
			}
		}
		return -1
	}

	fn split(self: &String, target: char) -> SplitResult {
		let count : ui8 = self.count(target) + 1
		let rtn : &String = malloc(size_of(String) * count)
		let offset : ui8 = 0
		for i in (0..count) {
			let aux = self.range(offset, self.len)
			let end = aux.find(target)
			if end == (-1) {
				end = aux.len
			}
			rtn[i] = aux.range(0, end)
			offset += end + 1
		}
		return new SplitResult { slice: rtn count: count }
	}

	fn is_empty(self: &String) -> bool {
		for i in (0..self.len) {
			if !self.data[i].is_whitespace() {
				return false
			}
		}
		return true
	}

	fn clone(self: &String) -> String {
		let alloc: &char = malloc(self.len)
		memcpy(alloc, self.data, self.len)
		return new String { data: alloc len: self.len capacity: self.capacity }
	}

	fn trim(self: &String) {
		let flag = false
		let l = 0
		while (l < self.len) and (!flag) {
			if self.data[l].is_whitespace() { l += 1 } else { flag = true }
		}
		let r = self.len
		while (r > 0) and (!flag) {
			if self.data[r].is_whitespace() { r -= 1 } else { flag = true }
		}
		let alloc: &char = malloc(r - l + 1)
		let aux : &char = self.data[l]
		memcpy(alloc, aux, r - l)
		realloc(self.data, r - l + 1)
		memcpy(self.data, alloc, r - l)
		self.data[r - l] = '\0'
		self.len = r - l
		self.capacity = self.len
		return
	}

	fn to_int(self: String) -> i8 {
		let result : i8 = 0
		for i in (0..self.len) {
			result = result * 10 + (self.data[i] - 48)
		}
		return result
	}

	fn free(self: &String) {
		if self.len > 0 {
			free(self.data)
		}
		return
	}

	fn fmt(self: &String) -> string {
		return self.data
	}
}
